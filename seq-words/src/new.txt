use std::{collections::{HashMap, HashSet}, rc::Rc, cell::Cell};

use indexmap::IndexSet;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize)]
struct Record {
    #[serde(rename = "encounterId")]
    encounter_id: String,
    doctor: String,
    division: String,
    #[serde(rename = "processedSOAP")]
    processed_soap: String,
}

#[derive(PartialEq, Eq, Hash, Debug)]
struct Key {
    doctor: String,
    division: String,
}

struct Value {
    encounter_ids: Vec<EncounterIdIndex>,
    min_parents_frequency: Cell<usize>,
}

const WHITE_SPACE: u32 = 1;
const WORD: u32 = 2;
const OTHER: u32 = 4;

#[derive(Debug, Deserialize)]
struct SubjectInfo {
    #[serde(rename = "SUBJECT_ID")]
    subject_id: String,
    #[serde(rename = "SUBJECT_NAME")]
    subject_name: String,
}

fn load_subject() -> anyhow::Result<HashMap<String, String>> {
    let mut reader = csv::Reader::from_path("subject.csv")?;
    let mut map = HashMap::new();
    for record in reader.deserialize() {
        let SubjectInfo { subject_id, subject_name } = record?;
        map.insert(subject_id, subject_name);
    }
    Ok(map)
}

const MIN_WORDS_NUM: usize = 4;
const MAX_WORDS_NUM: usize = usize::MAX;

#[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]
struct WordIndex(usize);
#[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]
struct EncounterIdIndex(usize);

struct IndexSets {
    words: IndexSet<String>,
    encounter_ids: IndexSet<String>,
}

impl IndexSets {
    fn new() -> Self {
        Self {
            words: IndexSet::new(),
            encounter_ids: IndexSet::new(),
        }
    }

    fn insert_word(&mut self, word: String) -> WordIndex {
        WordIndex(self.words.insert_full(word).0)
    }

    fn insert_encounter_id(&mut self, encounter_id: String) -> EncounterIdIndex {
        EncounterIdIndex(self.encounter_ids.insert_full(encounter_id).0)
    }

    fn get_word(&self, index: WordIndex) -> &str {
        self.words.get_index(index.0).unwrap()
    }

    fn get_encounter_id(&self, index: EncounterIdIndex) -> &str {
        self.encounter_ids.get_index(index.0).unwrap()
    }
}

fn main() -> anyhow::Result<()> {
    let subject_map = load_subject()?;

    let mut reader = csv::Reader::from_path("sample.csv")?;
    let mut buffer: Vec<WordIndex> = Vec::new();
    let mut data: HashMap<Key, HashMap<Vec<WordIndex>, Value>> = HashMap::new();
    
    let mut index_sets = IndexSets::new();
    
    for record in reader.deserialize() {
        let Record { encounter_id, doctor, division, processed_soap  } = record?;
        let encounter_id_index = index_sets.insert_encounter_id(encounter_id);

        let soap: Vec<Vec<(String, u32)>> = serde_json::from_str(&processed_soap)?;
        let key = Key {
            doctor, division,
        };
        
        let sentences = data.entry(key).or_insert_with(HashMap::new);
        
        for sentence in soap {
            let mut sentence_indices = Vec::with_capacity(sentence.len());
            for word in sentence {
                let (word, word_type) = word;
                let word_index: WordIndex = index_sets.insert_word(word);
                sentence_indices.push((word_index, word_type));
            }

            for i in 0..sentence_indices.len() {
                // if sentence_indices[i].1 != WORD {
                //     continue;
                // }
                buffer.clear();
                let mut words_num: usize = 0;
                for j in i..sentence_indices.len() {
                    buffer.push(sentence_indices[j].0);
                    
                    // if sentence_indices[j].1 != WORD && j < sentence_indices.len() - 1 {
                    //     continue;
                    // }
                    
                    if sentence_indices[j].1 == WORD {
                        words_num += 1;
                        if words_num > MAX_WORDS_NUM {
                            break;
                        }
                    }
                    if words_num >= MIN_WORDS_NUM {
                        let value = sentences.entry(buffer.clone()).or_insert_with(|| Value { encounter_ids: Vec::new(), min_parents_frequency: Cell::new(usize::MAX) });
                        value.encounter_ids.push(encounter_id_index);
                    }
                }
            }
        }
    }

    for (_, map) in &data {
        for (key, value) in map.iter() {
            let freq = value.encounter_ids.len();
            if let Some(child) = map.get(&key[1..]) {
                child.min_parents_frequency.set(child.min_parents_frequency.get().min(freq));
            }
            if let Some(child) = map.get(&key[0..(key.len()-1)]) {
                child.min_parents_frequency.set(child.min_parents_frequency.get().min(freq));
            }
        }
    }

    let mut writer = csv::Writer::from_path("output.csv")?;
    writer.write_record(&["doctor", "division", "sentence", "frequency", "encounter_ids"])?;

    for (key, value) in data {
        for (sentence, value) in value {
            let frequency = value.encounter_ids.len();
            if frequency < 2 || frequency <= value.min_parents_frequency.get() {
                continue;
            }

            let mut real_sentence = String::new();
            for word_index in sentence {
                real_sentence.push_str(index_sets.get_word(word_index));
            }
            let division = subject_map.get(&key.division).unwrap_or(&key.division);

            let mut real_encounter_ids = String::new();
            for encounter_id_index in value.encounter_ids {
                if !real_encounter_ids.is_empty() {
                    real_encounter_ids.push_str(", ");
                }
                real_encounter_ids.push_str(index_sets.get_encounter_id(encounter_id_index));
                
            }
            writer.write_record(&[&key.doctor, division, &real_sentence, &frequency.to_string(), &real_encounter_ids])?;
        }
    }
    Ok(())
}
